"""
<4> 1이 될때까지 해설은 3-5.py, 3-6.py

어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.
*단, 두 번째 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다.

1. N에서 1을 뺀다.
2. N을 K로 나눈다.

예를 들어 N이 17, K가 4라고 가정합시다. 이때 1번 과정을 한 번 수행하면 N은 16이 됩니다.
이후에 2번의 과정을 두 번 수행하면 N은 1이 됩니다.
결과적으로 이 경우 전체 과정을 실행한 횟수는 3이 됩니다. 이는 N을 1로 만드는 최소 횟수입니다.

조건
첫째 줄에 N(1<=N<=100,000)과 K(2<=K<=100,000)가 공백을 기준으로 하여 각각 자연수로 주어집니다.
출력조건 첫재 줄에 N이 1이 도리때까지 1번 혹은 2번의 과정을 수행해야하는 횟수의 최솟값을 출력합니다.
풀이 1회 : ch3_4_20211005(input_str) -> 답안이 더 효율적으로 풀이를 하였음. 내가 푼건 단순한 버전
"""































"""
풀이 2021-10-05
"""

def ch3_4_20211005(input_str):
    n, k = input_str.split(' ')
    n, k = int(n), int(k)

    cnt = 0
    while n != 1:
        if n % k == 0:
            n = n // k
        else:
            n -= 1
        cnt += 1
    return cnt

_input = '17 4'
# print(ch3_4_20211005(_input))


def answer3_4():
    n, k = map(int, input().split())

    result=0

    while True:
        #N이  K로 나누어 떨어지는 수가 될 때까지
        target = (n//k)*k #n이 k로 떨어지지 않을때 가장 가까운 k로 나누어 떨어지는 수가 어떤 것일지 확인할 때 사용

        #한번에 n을 빼는 연산 수행
        result += (n-target)

        n = target
        #n이 k보다 작을때(더 이상 나눌 수 없을 때) 반복문 탈출
        if n < k :
            break
        result +=1
        n//=k
    result += (n-1)
    print(result)
    return result

answer3_4()